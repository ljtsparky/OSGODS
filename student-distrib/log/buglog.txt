## BUG 1

**Expected Result：** Press q on the keyboard, display single q on the screen

**Actual Result：** Press q on the keyboard, display q and a number on the screen

**Explanation；** When press q and loose q, the linux get two signal, so to display q, we have to mask the second signal.

## BUG 2

bug: The screen is static after executing the test_interrupt function but not alternating

solution: Set the frequency of RTC from 1024Hz to 2Hz

## BUG 3

bug: RTC can't get another interrupt after handling one interrupt

solution: Read the RTC status register C at the end of each handler to make sure that RTC can receive other interrupts

## BUG 4
2022 Oct 15 Li jiatong: paging init, when we initialize the page dir entry , there are two different entries to be entered, so we need to treat them differently. 


we solved the bug by setting the page size of the second entry of page dir to be 1 meaning that it corresponds to a 4MB page space, and then make the address of the 4MB space 


which is 0x400000 to right shift 12 because 12 is exactly 4MB, as a result we get 1 to put into the base_address part.


## BUG 5
2022 Oct 15 Li Jiatong: about pic initialization: we found it hard to know whether we initialized those successfully, so used some printf to indicate we finished the init

## BUG 6
2022 Oct 24 Li Jiatong: about keyboard backspace, we used to have the case that backspace won't go back to the remembered position of last line, we solved this by adding a array to remember the last position and when scrolling happened also scroll this array to keep the information correct.

## BUG 7
2022 Oct 24 Li Jiatong: terminal didn't show the terminal writing information because we wrongly made the keyboard index as its input nbytes, however, the keyb index is cleared in the terminal_read, so it is 0 when it goes to write. To solve this , we just used the return value of read to be the input value of write.
## BUG 8
2022 Nov 7 Shen Xing: first we find that our ls command cannot jump to the halt and return to the execute, this is a really hard bug that cost us several hours. Then we find that it is bucause our pid and parent_id wrong, and we set them in the create pcb and the execute, then the functions works quite well.

## BUG 9
2022 NOV 7 Shen Xing: also the bug that happens in halt and execute, when we execute halt, we found that our function jump into a unknown place. So we check the halt function for a while, it is not a difficult bug, and finally we found that we didn't set the current pcb in the halt function.
## bug 10
halt with leave return will works
## we need cli sti for terminal write
## bug 11
2022 Nov 16, In filesystem.c, when using strlen, fname type didn't transfer to int8_t* type. In terminal read, we can't have cli before the while loop that keeps waiting for keyboard enter signal, cause it stops any interrupt from keyboard and we can't type in anything.
## bug 12
2022 Nov 18, in rtc interrupt handler, used inode=-1 to indicate this fd is rtc file, and then in handler, increase the file position of it,
which then make rtc read while loop ends, the reason to use this new approach is that:
## bug 13
2022 Nov 18, ljt: in syscall.c uint8_t** screen_start input, when determine whether it's in the range of 128 to 132 MB, we need to use
(int)screen_start
## bug 14
2022 Nov 18, ljt: in execute.c, we need to update the pcb->active to be 1 when created and 0 when it is halted and exit. That's because when we
go through all the 6 pcb's, there might be some active pcb after the unactive ones, and we need to know which to be edit its
pcb->file_descriptor[fd].file_position and in rtc read while loop will end?